<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="author" content="Salah Al-Wafi">
    <meta name="developer" content="S.W Creative">
    <title>Pro AI - Salah Al-Wafi Edition</title>
    
    <link rel="preconnect" href="https://cdn.tailwindcss.com">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" defer></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css" media="print" onload="this.media='all'">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js" defer></script>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700&display=swap" rel="stylesheet" media="print" onload="this.media='all'">
    
    <style>
        :root { --primary: #7c3aed; --bg: #030712; }
        body { margin: 0; font-family: 'Cairo', sans-serif; background: var(--bg); color: white; display: flex; height: 100dvh; overflow: hidden; position: fixed; width: 100%; }
        .sidebar { width: 280px; background: #0f172a; border-left: 1px solid #1f2937; transition: transform 0.3s ease; z-index: 60; flex-shrink: 0; will-change: transform; }
        .sidebar-overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 55; backdrop-filter: blur(2px); }
        .sidebar-overlay.active { display: block; }
        @media (max-width: 1024px) { .sidebar { position: fixed; top: 0; right: -280px; height: 100%; transform: translateX(0); } .sidebar.open { transform: translateX(-280px); } }
        .main-content { flex: 1; display: flex; flex-direction: column; position: relative; min-width: 0; height: 100%; }
        .chat-container { flex: 1; overflow-y: auto; padding: 20px; scroll-behavior: smooth; display: flex; flex-direction: column; gap: 20px; contain: content; padding-bottom: 40px; }
        .message-user { align-self: flex-end; background: #1e293b; border-radius: 18px 18px 0 18px; max-width: 85%; padding: 12px 16px; border: 1px solid #334155; position: relative; }
        .message-ai { align-self: flex-start; background: rgba(124,58,237,0.05); border: 1px solid rgba(124,58,237,0.2); border-radius: 18px 18px 18px 0; max-width: 85%; padding: 12px 16px; line-height: 1.8; color: #e2e8f0; position: relative; }
        .msg-actions { display: flex; gap: 8px; margin-top: 10px; opacity: 0.6; transition: opacity 0.2s; }
        .msg-actions:hover { opacity: 1; }
        .msg-btn { font-size: 14px; cursor: pointer; color: #7c3aed; padding: 4px 8px; border-radius: 6px; background: rgba(124,58,237,0.1); transition: all 0.2s; }
        .msg-btn:hover { background: rgba(124,58,237,0.2); }
        .msg-btn.copied { color: #10b981; background: rgba(16,185,129,0.1); }
        .input-wrapper { background: #0f172a; border-top: 1px solid #1e293b; padding: 15px; position: sticky; bottom: 0; width: 100%; z-index: 50; }
        textarea { resize: none; max-height: 150px; width: 100%; background: transparent; color: #e2e8f0; border: none; outline: none; font-family: 'Cairo'; }
        .typing-dot { width: 6px; height: 6px; background: var(--primary); border-radius: 50%; display: inline-block; margin: 0 2px; animation: bounce 1.4s infinite ease-in-out both; }
        @keyframes bounce { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1); } }
        .signature { font-size: 10px; color: #4b5563; text-align: center; padding: 10px; letter-spacing: 1px; }
        .mic-active { color: #ef4444 !important; animation: pulse-red 1.5s infinite; }
        @keyframes pulse-red { 0% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.2); opacity: 0.7; } 100% { transform: scale(1); opacity: 1; } }
        .action-btn { background: rgba(31, 41, 55, 0.8); border: 1px solid #374151; color: #9ca3af; padding: 6px 12px; border-radius: 8px; font-size: 12px; display: flex; align-items: center; gap: 6px; transition: all 0.2s; }
        .action-btn:hover { background: #374151; color: white; }
    </style>
</head>
<body>
    <div id="overlay" class="sidebar-overlay" onclick="toggleSidebar()"></div>
    <aside id="sidebar" class="sidebar flex flex-col">
        <div class="p-4 border-b border-gray-800 flex justify-between items-center">
            <button onclick="newChat()" class="flex-1 bg-gradient-to-r from-purple-600 to-blue-600 hover:from-purple-700 hover:to-blue-700 p-3 rounded-xl font-bold shadow-lg transition-transform active:scale-95">+ Ù…Ø­Ø§Ø¯Ø«Ø© Ø¬Ø¯ÙŠØ¯Ø©</button>
            <button onclick="toggleSidebar()" class="lg:hidden mr-2 text-gray-400 text-2xl">Ã—</button>
        </div>
        <div id="historyList" class="p-4 flex-1 overflow-y-auto text-gray-400 text-sm space-y-2">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø­Ø§Ø¯Ø«Ø§Øª Ø³Ø§Ø¨Ù‚Ø©</div>
        <div class="p-4 border-t border-gray-800 space-y-3">
            <div class="signature">DESIGNED BY ENG.SALAH AL-WAFI â—ˆ 2025</div>
        </div>
    </aside>

    <main class="main-content">
        <header class="h-16 flex items-center justify-between px-6 bg-gray-900/50 border-b border-gray-800 backdrop-blur-md shrink-0">
            <div class="flex items-center gap-3">
                <button onclick="toggleSidebar()" class="lg:hidden text-2xl text-purple-400">â˜°</button>
                <h1 class="text-xl font-bold bg-gradient-to-r from-purple-400 to-blue-400 bg-clip-text text-transparent">Pro AI</h1>
            </div>
            <div class="flex items-center gap-2">
                <button onclick="downloadPDF()" class="action-btn"><span>ğŸ“„</span> <span class="hidden sm:inline">ØªØ­Ù…ÙŠÙ„ PDF</span></button>
                <button onclick="clearCurrentChat()" class="action-btn text-red-400"><span>ğŸ—‘ï¸</span> <span class="hidden sm:inline">Ù…Ø³Ø­</span></button>
            </div>
        </header>

        <div id="chat-window" class="chat-container">
            <div id="welcome" class="m-auto text-center opacity-40">
                <div class="text-6xl mb-4">âœ¨</div>
                <h2 class="text-2xl font-bold">Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Pro AI</h2>
                <p class="text-sm mt-2">Ø¨ÙˆØ§Ø³Ø·Ø© ØµÙ„Ø§Ø­ Ø§Ù„ÙˆØ§ÙÙŠ</p>
            </div>
        </div>

        <div class="input-wrapper">
            <div class="max-w-4xl mx-auto flex items-end gap-2 bg-gray-900 p-2 rounded-2xl border border-gray-800 shadow-2xl">
                <button onclick="document.getElementById('pdfInput').click()" class="p-3 text-gray-400 hover:text-purple-400" title="Ø¥Ø±ÙØ§Ù‚ ØµÙˆØ±Ø© Ø£Ùˆ PDF">ğŸ“</button>
                <textarea id="userInput" rows="1" placeholder="Ø§Ø³Ø£Ù„Ù†ÙŠ Ø¹Ù† Ø£ÙŠ Ø´ÙŠØ¡..." oninput="this.style.height='auto';this.style.height=this.scrollHeight+'px'"></textarea>
                <button id="voiceBtn" class="p-3 text-gray-400 hover:text-purple-400 transition-all" title="Ø¥Ø¯Ø®Ø§Ù„ ØµÙˆØªÙŠ">ğŸ¤</button>
                <button id="sendBtn" onclick="sendMessage()" class="bg-purple-600 hover:bg-purple-500 p-3 rounded-xl transition-all active:scale-90">â¤</button>
                <input type="file" id="pdfInput" accept="image/*,application/pdf" class="hidden" onchange="handlePdfUpload(this)">
            </div>
        </div>
    </main>

    <script>
        window.addEventListener('DOMContentLoaded', () => {
            if (typeof marked !== 'undefined') {
                marked.setOptions({ highlight: (code, lang) => typeof hljs !== 'undefined' ? hljs.highlightAuto(code).value : code, breaks: true });
            }

            const chatWindow = document.getElementById("chat-window");
            const userInput = document.getElementById("userInput");
            const sendBtn = document.getElementById("sendBtn");
            const voiceBtn = document.getElementById("voiceBtn");
            const historyList = document.getElementById("historyList");
            const overlay = document.getElementById("overlay");

            let chatHistory = JSON.parse(localStorage.getItem("chats") || "[]");
            let currentId = localStorage.getItem("currentChatId") ? parseInt(localStorage.getItem("currentChatId")) : null;
            let pdfContent = "";
            let attachedImage = null; // Store compressed image data

            // Image Compression Function - Optimized for API
            window.compressImage = (file) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => {
                            const canvas = document.createElement('canvas');
                            let width = img.width;
                            let height = img.height;
                            const maxSize = 1024;
                            
                            // Resize to fit within maxSize
                            if (width > height) {
                                if (width > maxSize) { height = Math.round((height * maxSize) / width); width = maxSize; }
                            } else {
                                if (height > maxSize) { width = Math.round((width * maxSize) / height); height = maxSize; }
                            }
                            
                            canvas.width = width;
                            canvas.height = height;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, width, height);
                            
                            // Convert to JPEG with quality 0.6
                            const compressed = canvas.toDataURL('image/jpeg', 0.6);
                            
                            // Extract raw Base64 (remove data URL prefix)
                            const base64 = compressed.split(',')[1];
                            
                            // Calculate size in MB
                            const sizeInMB = (base64.length * 0.75) / (1024 * 1024);
                            
                            console.log(`Image compressed: ${width}x${height}, Size: ${sizeInMB.toFixed(2)} MB`);
                            
                            if (sizeInMB > 4) {
                                reject(new Error('Ø­Ø¬Ù… Ø§Ù„ØµÙˆØ±Ø© ÙƒØ¨ÙŠØ± Ø¬Ø¯Ø§Ù‹ (Ø£ÙƒØ«Ø± Ù…Ù† 4 MB). ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± ØµÙˆØ±Ø© Ø£ØµØºØ±.'));
                            } else {
                                // Return clean Base64 without prefix
                                resolve({ base64, mimeType: 'image/jpeg', size: sizeInMB });
                            }
                        };
                        img.onerror = () => reject(new Error('ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©'));
                        img.src = e.target.result;
                    };
                    reader.onerror = () => reject(new Error('ÙØ´Ù„ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…Ù„Ù'));
                    reader.readAsDataURL(file);
                });
            };

            // 1. Speech Synthesis
            let currentSpeakingBtn = null;
            let isSpeaking = false;
            window.speakText = (text, btn) => {
                if (isSpeaking && currentSpeakingBtn === btn) {
                    window.speechSynthesis.cancel();
                    isSpeaking = false;
                    btn.innerHTML = 'ğŸ”ˆ';
                    currentSpeakingBtn = null;
                } else {
                    if (currentSpeakingBtn) currentSpeakingBtn.innerHTML = 'ğŸ”ˆ';
                    window.speechSynthesis.cancel();
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.lang = 'ar-SA';
                    btn.innerHTML = 'â¸ï¸';
                    isSpeaking = true;
                    currentSpeakingBtn = btn;
                    utterance.onend = () => { btn.innerHTML = 'ğŸ”ˆ'; isSpeaking = false; currentSpeakingBtn = null; };
                    window.speechSynthesis.speak(utterance);
                }
            };

            // 2. Copy Text
            window.copyText = async (text, btn) => {
                try {
                    await navigator.clipboard.writeText(text);
                    const old = btn.innerHTML;
                    btn.innerHTML = 'âœ… ØªÙ… Ø§Ù„Ù†Ø³Ø®';
                    btn.classList.add('copied');
                    setTimeout(() => { btn.innerHTML = old; btn.classList.remove('copied'); }, 2000);
                } catch (e) { alert('ÙØ´Ù„ Ø§Ù„Ù†Ø³Ø®'); }
            };

            // 3. PDF Export
            window.downloadPDF = () => {
                const chat = chatHistory.find(c => c.id === currentId);
                if (!chat || !chat.messages.length) return alert("Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø­Ø§Ø¯Ø«Ø©!");
                const container = document.createElement('div');
                container.style.cssText = 'padding: 40px; color: black; background: white; font-family: Cairo, sans-serif; direction: rtl;';
                container.innerHTML = `<div style="border-bottom: 3px solid #7c3aed; padding-bottom: 20px; margin-bottom: 30px; text-align: center;">
                    <h1 style="color: #7c3aed; margin: 0; font-size: 24px;">Ø³Ø¬Ù„ Ù…Ø­Ø§Ø¯Ø«Ø© Pro AI</h1>
                    <p style="color: #666; font-size: 12px;">Ø§Ù„ØªØ§Ø±ÙŠØ®: ${new Date().toLocaleDateString('ar-SA')}</p>
                </div><div id="pdf-body"></div>
                <div style="border-top: 1px solid #ddd; padding-top: 20px; margin-top: 30px; text-align: center; color: #666; font-size: 12px;">
                    <div>ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù‡Ø°Ø§ Ø§Ù„ØªÙ‚Ø±ÙŠØ± Ø¨ÙˆØ§Ø³Ø·Ø© <span style="direction: ltr; unicode-bidi: embed; display: inline-block; font-weight: bold;">Pro AI</span></div>
                    <div style="margin-top: 5px; font-weight: bold; color: #333;">ENG. SALAH AL-WAFI</div>
                </div>`;
                const body = container.querySelector('#pdf-body');
                chat.messages.forEach(m => {
                    const div = document.createElement('div');
                    div.style.cssText = `margin-bottom: 20px; padding: 15px; border-radius: 8px; ${m.role === 'user' ? 'background: #f0f0f0; border-right: 4px solid #3b82f6;' : 'background: #f3f0ff; border-right: 4px solid #7c3aed;'}`;
                    const name = m.role === 'user' ? 'ğŸ‘¤ Ø£Ù†Øª' : '<span style="direction: ltr; unicode-bidi: embed; display: inline-block;">Pro AI</span> ğŸ¤–';
                    div.innerHTML = `<div style="font-weight: bold; margin-bottom: 8px;">${name}</div><div style="font-size: 13px;">${m.content}</div>`;
                    body.appendChild(div);
                });
                html2pdf().set({ margin: 10, filename: 'Ø³Ø¬Ù„_Ù…Ø­Ø§Ø¯Ø«Ø©.pdf', html2canvas: { scale: 2 }, jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' } }).from(container).save();
            };

            // 4. Clear Chat
            window.clearCurrentChat = () => {
                if (confirm("Ù…Ø³Ø­ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©ØŸ")) {
                    const chat = chatHistory.find(c => c.id === currentId);
                    if (chat) { chat.messages = []; saveChats(); renderChat(); }
                }
            };

            // 5. Voice Input
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (SpeechRecognition) {
                const rec = new SpeechRecognition();
                rec.lang = 'ar-SA';
                let active = false;
                voiceBtn.onclick = () => active ? rec.stop() : rec.start();
                rec.onstart = () => { active = true; voiceBtn.classList.add('mic-active'); userInput.placeholder = "Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§Ø³ØªÙ…Ø§Ø¹..."; };
                rec.onend = () => { active = false; voiceBtn.classList.remove('mic-active'); userInput.placeholder = "Ø§Ø³Ø£Ù„Ù†ÙŠ Ø¹Ù† Ø£ÙŠ Ø´ÙŠØ¡..."; };
                rec.onresult = (e) => { userInput.value += e.results[0][0].transcript; userInput.style.height = 'auto'; userInput.style.height = userInput.scrollHeight + 'px'; };
            }

            // Chat Core
            window.toggleSidebar = () => { document.getElementById('sidebar').classList.toggle('open'); overlay.classList.toggle('active'); };
            const saveChats = () => { localStorage.setItem("chats", JSON.stringify(chatHistory)); localStorage.setItem("currentChatId", currentId); };
            window.newChat = () => { const id = Date.now(); chatHistory.unshift({ id, title: "Ù…Ø­Ø§Ø¯Ø«Ø© Ø¬Ø¯ÙŠØ¯Ø©", messages: [] }); currentId = id; saveChats(); renderHistory(); renderChat(); if (window.innerWidth < 1024) toggleSidebar(); };
            
            const renderHistory = () => {
                historyList.innerHTML = chatHistory.length ? "" : '<div class="text-center opacity-40">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø­Ø§Ø¯Ø«Ø§Øª</div>';
                chatHistory.forEach(c => {
                    const d = document.createElement("div");
                    d.className = `p-3 rounded-lg cursor-pointer transition-all flex justify-between items-center group ${c.id === currentId ? "bg-purple-600/20 text-white border border-purple-500/30" : "hover:bg-gray-800 text-gray-400"}`;
                    d.innerHTML = `<span class="truncate flex-1">${c.title}</span><button class="opacity-0 group-hover:opacity-100 text-red-500 px-2" onclick="deleteChat(event, ${c.id})">Ã—</button>`;
                    d.onclick = () => { currentId = c.id; saveChats(); renderHistory(); renderChat(); if (window.innerWidth < 1024) toggleSidebar(); };
                    historyList.appendChild(d);
                });
            };

            window.deleteChat = (e, id) => { e.stopPropagation(); chatHistory = chatHistory.filter(c => c.id !== id); if (currentId === id) currentId = chatHistory.length ? chatHistory[0].id : null; saveChats(); renderHistory(); renderChat(); };

            const renderChat = () => {
                chatWindow.innerHTML = "";
                const chat = chatHistory.find(c => c.id === currentId);
                if (!chat || !chat.messages.length) { chatWindow.innerHTML = `<div class="m-auto text-center opacity-40"><div class="text-6xl mb-4">ğŸš€</div><h2 class="text-2xl font-bold">Ø£Ù‡Ù„Ø§Ù‹ Ø¨ÙƒØŒ ÙƒÙŠÙ Ø£Ø³Ø§Ø¹Ø¯ÙƒØŸ</h2></div>`; return; }
                chat.messages.forEach(m => addMessageUI(m.role, m.content));
            };

            const addMessageUI = (role, text) => {
                const div = document.createElement("div");
                div.className = role === "user" ? "message-user" : "message-ai";
                if (role === "ai") {
                    const clean = text.replace(/<\/?[^>]+(>|$)/g, "");
                    div.innerHTML = `<div class="msg-content">${typeof marked !== 'undefined' ? marked.parse(text) : text}</div>
                        <div class="msg-actions">
                            <span class="msg-btn" onclick="speakText(\`${clean.replace(/`/g, '\\`').replace(/\$/g, '\\$')}\`, this)">ğŸ”ˆ</span>
                            <span class="msg-btn" onclick="copyText(\`${text.replace(/`/g, '\\`').replace(/\$/g, '\\$')}\`, this)">ğŸ“‹</span>
                        </div>`;
                    if (typeof hljs !== 'undefined') div.querySelectorAll('pre code').forEach(b => hljs.highlightElement(b));
                } else { div.textContent = text; }
                chatWindow.appendChild(div);
                chatWindow.scrollTop = chatWindow.scrollHeight;
                return div;
            };

            window.handlePdfUpload = async (input) => {
                const file = input.files[0];
                if (!file) return;
                
                if (file.type === 'application/pdf') {
                    const status = addMessageUI("ai", "Ø¬Ø§Ø±ÙŠ Ù‚Ø±Ø§Ø¡Ø© PDF...");
                    try {
                        const buffer = await file.arrayBuffer();
                        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                        const pdf = await pdfjsLib.getDocument({data: buffer}).promise;
                        let text = "";
                        for (let i = 1; i <= pdf.numPages; i++) {
                            const page = await pdf.getPage(i);
                            const content = await page.getTextContent();
                            text += content.items.map(item => item.str).join(" ") + " ";
                        }
                        pdfContent = text;
                        status.innerHTML = "âœ… ØªÙ… ØªØ­Ù…ÙŠÙ„ PDF Ø¨Ù†Ø¬Ø§Ø­.";
                    } catch (e) { 
                        status.innerHTML = "âŒ Ø®Ø·Ø£ ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…Ù„Ù."; 
                        pdfContent = "";
                    }
                } else if (file.type.startsWith('image/')) {
                    try {
                        const status = addMessageUI("ai", "Ø¬Ø§Ø±ÙŠ Ø¶ØºØ· Ø§Ù„ØµÙˆØ±Ø©...");
                        const compressed = await compressImage(file);
                        attachedImage = compressed;
                        status.innerHTML = `âœ… ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© Ø¨Ù†Ø¬Ø§Ø­ (${compressed.size.toFixed(2)} MB)`;
                    } catch (e) {
                        addMessageUI("ai", `âŒ ${e.message}`);
                        attachedImage = null; // Ensure state is reset
                    }
                }
                
                // Clear file input
                input.value = "";
            };

            window.sendMessage = async () => {
                const text = userInput.value.trim();
                if (!text && !pdfContent && !attachedImage) return;
                if (!currentId) newChat();
                const chat = chatHistory.find(c => c.id === currentId);
                if (!chat.messages.length) chat.title = text.substring(0, 25);
                
                // Add user message
                chat.messages.push({ role: "user", content: text });
                const userDiv = addMessageUI("user", text);
                if (attachedImage) {
                    const img = document.createElement('img');
                    img.src = `data:${attachedImage.mimeType};base64,${attachedImage.base64}`;
                    img.style.cssText = 'max-width: 200px; border-radius: 8px; margin-top: 8px;';
                    userDiv.appendChild(img);
                }
                
                userInput.value = "";
                userInput.style.height = 'auto';
                sendBtn.disabled = true;
                const loading = addMessageUI("ai", '<div class="typing-dot"></div><div class="typing-dot"></div><div class="typing-dot"></div>');
                
                try {
                    let payload = {};
                    
                    // SEPARATE LOGIC: Text-only vs Vision
                    if (attachedImage) {
                        // Vision API payload for image analysis
                        payload = {
                            model: "gpt-4o-mini",
                            messages: [{
                                role: "user",
                                content: [
                                    { type: "text", text: text || "Ø­Ù„Ù„ Ù‡Ø°Ù‡ Ø§Ù„ØµÙˆØ±Ø©" },
                                    { type: "image_url", image_url: { url: `data:${attachedImage.mimeType};base64,${attachedImage.base64}` } }
                                ]
                            }]
                        };
                        attachedImage = null; // Clear after building payload
                    } else {
                        // Text-only payload (standard chat)
                        payload = {
                            model: "llama-3.3-70b-versatile",
                            messages: [
                                { role: "system", content: "Ø£Ù†Øª Pro AIØŒ Ù…Ø³Ø§Ø¹Ø¯ Ø°ÙƒÙŠ Ø·ÙˆØ±Ù‡ Ø§Ù„Ù…Ù‡Ù†Ø¯Ø³ ØµÙ„Ø§Ø­ Ø§Ù„ÙˆØ§ÙÙŠ. Ø±Ø¯ Ø¨Ø·Ø±ÙŠÙ‚Ø© ÙˆØ¯ÙŠØ© ÙˆÙ…ÙÙŠØ¯Ø©." },
                                ...chat.messages.map(m => ({
                                    role: m.role === "ai" ? "assistant" : "user",
                                    content: m.content
                                }))
                            ]
                        };
                    }
                    
                    // Send request with proper headers
                    const res = await fetch("/.netlify/functions/chat", { 
                        method: "POST",
                        headers: { 
                            "Content-Type": "application/json",
                            "Accept": "application/json"
                        },
                        body: JSON.stringify(payload)
                    });
                    
                    // Handle response
                    if (!res.ok) {
                        const errorData = await res.text();
                        throw new Error(`Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ø§Ù„Ø³ÙŠØ±ÙØ±: ${res.status}`);
                    }
                    
                    const data = await res.json();
                    loading.remove();
                    
                    if (data.choices && data.choices[0] && data.choices[0].message) {
                        const reply = data.choices[0].message.content;
                        chat.messages.push({ role: "ai", content: reply });
                        addMessageUI("ai", reply);
                        saveChats();
                    } else if (data.error) {
                        throw new Error(data.error.message || 'Ø®Ø·Ø£ Ù…Ù† Ø§Ù„Ø³ÙŠØ±ÙØ±');
                    } else {
                        throw new Error('Ø§Ø³ØªØ¬Ø§Ø¨Ø© ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹Ø©');
                    }
                } catch (e) {
                    console.error('Send message error:', e);
                    loading.remove();
                    addMessageUI("ai", `âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„: ${e.message}\n\nÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§ØªØµØ§Ù„Ùƒ Ø¨Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª ÙˆØ¥Ø¹Ø¯Ø§Ø¯Ø§Øª API.`);
                    attachedImage = null; // Reset state on error
                } finally {
                    sendBtn.disabled = false;
                }
            };

            userInput.onkeydown = (e) => { if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); sendMessage(); } };
            renderHistory(); renderChat();
        });
    </script>
</body>
</html>
